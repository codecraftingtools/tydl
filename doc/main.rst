Motivation
==========

Almost all computer programs, to one degree or another, rely on data
structures to organize and store the data manipulated by the program.  Within
a program, it is often desirable to interact with data structures in an
abstract way, without concern for the underlying physical representation or
layout.  When data is transmitted between programs, however, these details
become important.  This is true whether the data is transmitted via a network
connection, serial data stream, or data file.  Every program that directly
interacts with this data must understand underlying physical representation.
Unfortunately, if programs that interact with a common data structure are
written in different programming languages, or even simply compiled for
different computing architectures, the low-level representation of the data
structure may need to be specified in a different way.  Tydl was conceived as
a way to address this issue by providing a powerful language for
unambiguously describing data structures and an accompanying toolchain that,
when combined, greatly reduce the need for duplicated information and
hand-written boilerplate code.

Project Scope
=============

Language
--------

The first goal of the Tydl project is to implement a language that allows
*all* information about a data structure to be encoded in one format and
accessed in one place, from high-level semantic information to low-level
details regarding the physical representation.  This may include information
like field names, measurement units, numeric bounds (min/max), reference
frame, default value, description, title, scale factor, bit/byte endianness,
custom attributes, etc.  Having all of this information in one place eases
the software / documentation maintenence burden and reduces errors that stem
from `duplicated information`_ not being kept in sync.

In addition to providing a standardized and unified way of describing typical
data structures (e.g. arrays, records, bit fields and unions), Tydl also
aspires to support the definition of more sophisticated types than are
available in most mainstream programming languages.  This includes items like
tagged unions, discontiguous fields, variable-length arrays, "sliding" fields
that follow variable-length fields, derived fields (e.g. checksums), etc.

Front End
---------

The second goal of this project is to implement a Python-based front end that
parses Tydl-formatted type descriptions (that are easy to write and maintain)
and converts them into a standardized internal representation that is easy
for back-end code to process.  Code and documentation generators can then
leverage a common parsing engine instead of having to implement this
functionality independently.

Back Ends
---------

The Tydl project also aims to provide a set of Python-based back ends for
generating code and documentation from the standardized internal
representation produced by the parsing engine.  Back ends could be used to
generate:

- C++ message class wrappers (i.e. *smart structures*)
- Python bindings for *smart structures*
- API documentation
- Interface control documents
- Graphical data visualizers
- Graphical control applications
- Binary data post-processing tools

Some of these back ends may be provided as part of the Tydl project, while
others will be provided through external plug-ins.

Automatic generation of code and documentation from a single source
specification has many advantages.  Once the required tools are established,
this approach improves the consistency of class wrappers, eliminates
hand-written boilerplate code, minimizes the duplication of information,
reduces the maintenence burden, and maximizes productivity.

Command-Line Tool
-----------------

The final piece of the Tydl project is a common Python-based command-line
tool for invoking the front-end parser and passing information to the
back-end generators.

Status
======

This project is not in a generally useful state at the moment.  It currently
consists of some proof-of-concept utility code and simple, but functional,
example programs that demonstrate the desired C++ *Smart Structure* API.
There is no code generator at this point, but you can see the desired source
specification for some simple data types alongside the C++ code that would be
generated by running a command-line tool.

Installation Instructions
=========================

Make sure that `Git <cc:git-install>` is installed and then pull down the
Tydl `source code`_ from `GitHub <cc:github>` using these commands::

  mkdir -p ~/git
  cd ~/git
  git clone https://github.com/codecraftingtools/tydl.git

No further installation steps are required at this time.

Project Structure
=================

The project :github-repo:`Git repository <>` contains following directory
tree, with some files and subdirectories omitted for simplicity::
   
  ├── examples
  │   └── ex1
  │       ├── build.sh
  │       ├── generated
  │       │   ├── Child.hpp
  │       │   └── Parent.hpp
  │       └── src
  │           ├── ex1.cpp
  │           └── ex1.td
  └── include
      ├── tydl
      │   ├── Concrete.hpp
      │   ├── Field.hpp
      │   ├── Members.hpp
      │   ├── Record.hpp
      │   ├── Sizing.hpp
      │   ├── Sugar.hpp
      │   ├── functions.hpp
      │   ├── locators.hpp
      │   └── primitives.hpp
      └── tydl.hpp

The :repo:`include` directory contains shared Tydl C++ library header files
that are used to implement auto-generated C++ type classes.  The programming
interface for these files may change over time, so direct inclusion of these
headers from 3rd-party code is discouraged.

The :repo:`examples/ex1` directory demonstrates what an external project that
relies on Tydl might look like.  This example uses the Tydl syntax to define
data types (see :repo:`examples/ex1/src/ex1.td`) and then uses the resulting
Tydl-generated C++ data type classes in an example program
(i.e. :repo:`examples/ex1/src/ex1.cpp`).

The :repo:`examples/ex1/generated` directory contains code that would be
automatically generated from the type definitions if a code generation tool
was implemented.  This directory would be generated as part of the example
project's build process.

The :repo:`examples/ex1/build.sh` script contains the commands used to
build the example code.

Build Process
=============

The example code should compile and run under `Ubuntu<cc:ubuntu>`.
The only real prequisite for this is having a C++ compiler installed,
which can be accomplished using this command::

  sudo apt-get install build-essential

Once a C++ compiler is installed, the example code can be compiled and
executed like this::

  cd ~/git/tydl/examples/ex1
  ./build.sh
  ./ex1

Examples
========

Simple Record
-------------

For our first example, let us consider a very simple data structure: a record
with three fields.

.. table:: Position
   
   +--------+----------------------------------------------------------+
   | Field  | Type                                                     |
   +========+==========================================================+
   | x      | IEEE 754 Single-Precision Floating-Point (Little-Endian) |
   +--------+----------------------------------------------------------+
   | y      | IEEE 754 Single-Precision Floating-Point (Little-Endian) |
   +--------+----------------------------------------------------------+
   | z      | IEEE 754 Single-Precision Floating-Point (Little-Endian) |
   +--------+----------------------------------------------------------+

A simple declaration for this data structure in the Tydl syntax would be::

  import all: from: (Tydl, Tydl.Data.Types)

  Position: Record
    fields:
      x: Float32
      y: Float32
      z: Float32

We won't go into the details of the declaration syntax at this time, but
hopefully the meaning is intuitive.  Those who are curious can refer to the
`Wumps <cc:wumps>` documentation to find more information on the low-level
syntax that serves as a foundation for the Tydl language.

An auto-generated C++ *smart structure* class for this record could be used
like this::

  #include <generated/Position.hpp>
  #include <iostream>

  int main()
  {
    using namespace std;

    Position p1, p2;

    // chained setters
    p1.x(1.0)
      .y(2.0)
      .z(3.0);

    // assignment operators
    p1.x = 1.1;
    p1.x = p2.x;
    
    // getter
    cout << p1.x() << endl;

    return 0;
  }
  
.. _duplicated information:
     https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
.. _source code: https://github.com/codecraftingtools/tydl
